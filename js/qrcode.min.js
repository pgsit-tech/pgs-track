/**
 * QR Code Generator - å¯é ç‰ˆæœ¬
 * ä¼˜å…ˆä½¿ç”¨å¤šä¸ªåœ¨çº¿APIï¼Œç¡®ä¿äºŒç»´ç å¯æ‰«æ
 */

// QRç ç”Ÿæˆå™¨
window.QRCode = {
    toCanvas: function(canvas, text, options, callback) {
        try {
            // å¦‚æœcanvasæ˜¯å­—ç¬¦ä¸²IDï¼Œè·å–å…ƒç´ 
            if (typeof canvas === 'string') {
                canvas = document.getElementById(canvas);
            }

            // ç»Ÿä¸€å¤„ç†ä¸ºå®¹å™¨æ¨¡å¼
            if (canvas) {
                this.generateWithAPI(canvas, text, options, callback);
                return;
            }

            throw new Error('Canvas element not found');

        } catch (error) {
            console.error('QR Code generation error:', error);

            // é™çº§æ–¹æ¡ˆï¼šæ˜¾ç¤ºæ–‡æœ¬é“¾æ¥
            this.showFallbackText(canvas, text);

            if (callback) {
                callback(error);
            }
        }
    },

    toDataURL: function(text, options, callback) {
        try {
            // åˆ›å»ºä¸´æ—¶å®¹å™¨
            const tempContainer = document.createElement('div');
            tempContainer.style.position = 'absolute';
            tempContainer.style.left = '-9999px';
            document.body.appendChild(tempContainer);

            // ä½¿ç”¨toCanvasæ–¹æ³•ç”Ÿæˆ
            this.toCanvas(tempContainer, text, options, function(error) {
                if (error) {
                    document.body.removeChild(tempContainer);
                    if (callback) callback(error);
                    return;
                }

                // æŸ¥æ‰¾ç”Ÿæˆçš„canvasæˆ–img
                const canvas = tempContainer.querySelector('canvas');
                const img = tempContainer.querySelector('img');

                if (canvas) {
                    const dataURL = canvas.toDataURL('image/png');
                    document.body.removeChild(tempContainer);
                    if (callback) callback(null, dataURL);
                } else if (img) {
                    // å¦‚æœæ˜¯imgï¼Œè½¬æ¢ä¸ºcanvaså†è·å–dataURL
                    const newCanvas = document.createElement('canvas');
                    const ctx = newCanvas.getContext('2d');
                    newCanvas.width = img.width || 200;
                    newCanvas.height = img.height || 200;

                    img.onload = function() {
                        ctx.drawImage(img, 0, 0);
                        const dataURL = newCanvas.toDataURL('image/png');
                        document.body.removeChild(tempContainer);
                        if (callback) callback(null, dataURL);
                    };

                    img.onerror = function() {
                        document.body.removeChild(tempContainer);
                        if (callback) callback(new Error('Image load failed'));
                    };
                } else {
                    document.body.removeChild(tempContainer);
                    if (callback) callback(new Error('No canvas or image found'));
                }
            });

        } catch (error) {
            console.error('toDataURL error:', error);
            if (callback) callback(error);
        }
    },

    generateWithAPI: function(container, text, options, callback) {
        const size = options?.width || 200;

        // æ ¹æ®ç”¨æˆ·åé¦ˆï¼Œç›´æ¥ä½¿ç”¨QuickChart APIï¼ˆç¬¬4ä¸ªAPIï¼‰- å·²éªŒè¯å¯ç”¨
        const apiUrl = `https://quickchart.io/qr?text=${encodeURIComponent(text)}&size=${size}&format=png&margin=2`;

        console.log('ğŸ”— ä½¿ç”¨QuickChart APIç”ŸæˆQRç :', apiUrl);

        // åˆ›å»ºå›¾ç‰‡å…ƒç´ 
        const img = document.createElement('img');
        img.style.width = size + 'px';
        img.style.height = size + 'px';
        img.style.border = '1px solid #e5e7eb';
        img.style.borderRadius = '8px';
        img.style.display = 'block';
        img.style.margin = '0 auto';
        img.style.backgroundColor = '#ffffff';

        // ç›´æ¥ä½¿ç”¨QuickChart API
        img.onload = () => {
            console.log('âœ… QuickChart QRç ç”ŸæˆæˆåŠŸ');
            container.innerHTML = '';
            container.appendChild(img);

            // æ·»åŠ è¯´æ˜æ–‡å­—
            const caption = document.createElement('p');
            caption.textContent = 'ä½¿ç”¨Google Authenticatoræ‰«æä¸Šæ–¹äºŒç»´ç ';
            caption.style.textAlign = 'center';
            caption.style.margin = '15px 0 0 0';
            caption.style.fontSize = '14px';
            caption.style.color = '#6b7280';
            caption.style.fontWeight = '500';
            container.appendChild(caption);

            // æ·»åŠ å¤‡ç”¨è¯´æ˜
            const fallbackText = document.createElement('p');
            fallbackText.innerHTML = 'å¦‚æœæ‰«æå¤±è´¥ï¼Œè¯·ç‚¹å‡» <button onclick="showManualInput()" style="background: none; border: none; color: #2563eb; text-decoration: underline; cursor: pointer;">æ‰‹åŠ¨è¾“å…¥</button>';
            fallbackText.style.textAlign = 'center';
            fallbackText.style.margin = '5px 0 0 0';
            fallbackText.style.fontSize = '12px';
            fallbackText.style.color = '#9ca3af';
            container.appendChild(fallbackText);

            if (callback) callback(null);
        };

        img.onerror = () => {
            console.error('âŒ QuickChart QRç ç”Ÿæˆå¤±è´¥ï¼Œæ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥ç•Œé¢');
            this.showFallbackText(container, text);
            if (callback) callback(new Error('QRç ç”Ÿæˆå¤±è´¥'));
        };

        // è®¾ç½®å›¾ç‰‡æºä¸ºQuickChart API
        img.src = apiUrl;

        // 10ç§’è¶…æ—¶
        setTimeout(() => {
            if (!img.complete || img.naturalWidth === 0) {
                console.log('â° QRç ç”Ÿæˆè¶…æ—¶ï¼Œæ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥ç•Œé¢');
                img.onerror();
            }
        }, 10000);
    },

    generateLocalQR: function(container, text, options, callback) {
        console.log('ä½¿ç”¨æœ¬åœ°QRç ç”Ÿæˆ');

        const canvas = document.createElement('canvas');
        const size = options?.width || 200;
        canvas.width = size;
        canvas.height = size;
        canvas.style.border = '1px solid #e5e7eb';
        canvas.style.borderRadius = '8px';
        canvas.style.display = 'block';
        canvas.style.margin = '0 auto';

        try {
            const qrData = this.generateQRCode(text);
            this.renderQRCode(canvas, qrData, options);

            container.innerHTML = '';
            container.appendChild(canvas);

            // æ·»åŠ è¯´æ˜æ–‡å­—
            const caption = document.createElement('p');
            caption.textContent = 'æœ¬åœ°ç”Ÿæˆçš„äºŒç»´ç ';
            caption.style.textAlign = 'center';
            caption.style.margin = '10px 0 0 0';
            caption.style.fontSize = '14px';
            caption.style.color = '#6b7280';
            container.appendChild(caption);

            if (callback) callback(null);

        } catch (error) {
            console.error('æœ¬åœ°QRç ç”Ÿæˆå¤±è´¥:', error);
            this.showFallbackText(container, text);
            if (callback) callback(error);
        }
    },

    generateQRCode: function(text) {
        // ç®€åŒ–çš„QRç æ•°æ®ç”Ÿæˆ
        // è¿™é‡Œä½¿ç”¨ä¸€ä¸ªåŸºæœ¬çš„QRç æ¨¡å¼
        const size = 25; // 25x25 æ¨¡å—
        const matrix = Array(size).fill().map(() => Array(size).fill(false));

        // æ·»åŠ å®šä½æ ‡è®°
        this.addFinderPattern(matrix, 0, 0);
        this.addFinderPattern(matrix, size - 7, 0);
        this.addFinderPattern(matrix, 0, size - 7);

        // æ·»åŠ åˆ†éš”ç¬¦
        this.addSeparators(matrix, size);

        // æ·»åŠ æ—¶åºå›¾æ¡ˆ
        this.addTimingPatterns(matrix, size);

        // æ·»åŠ æ•°æ®ï¼ˆåŸºäºæ–‡æœ¬å†…å®¹çš„ç®€åŒ–ç¼–ç ï¼‰
        this.addDataModules(matrix, text, size);

        return matrix;
    },

    renderQRCode: function(canvas, matrix, options) {
        const size = options?.width || 200;
        const moduleCount = matrix.length;
        const moduleSize = Math.floor(size / moduleCount);
        const actualSize = moduleSize * moduleCount;

        canvas.width = actualSize;
        canvas.height = actualSize;

        const ctx = canvas.getContext('2d');

        // æ¸…ç©ºèƒŒæ™¯
        ctx.fillStyle = options?.color?.light || '#ffffff';
        ctx.fillRect(0, 0, actualSize, actualSize);

        // ç»˜åˆ¶æ¨¡å—
        ctx.fillStyle = options?.color?.dark || '#000000';

        for (let row = 0; row < moduleCount; row++) {
            for (let col = 0; col < moduleCount; col++) {
                if (matrix[row][col]) {
                    ctx.fillRect(
                        col * moduleSize,
                        row * moduleSize,
                        moduleSize,
                        moduleSize
                    );
                }
            }
        }
    },
    
    addFinderPattern: function(matrix, startRow, startCol) {
        // æ·»åŠ 7x7çš„å®šä½æ ‡è®°
        for (let row = 0; row < 7; row++) {
            for (let col = 0; col < 7; col++) {
                const r = startRow + row;
                const c = startCol + col;
                if (r < matrix.length && c < matrix[0].length) {
                    // å¤–æ¡†
                    if (row === 0 || row === 6 || col === 0 || col === 6) {
                        matrix[r][c] = true;
                    }
                    // å†…éƒ¨3x3æ–¹å—
                    else if (row >= 2 && row <= 4 && col >= 2 && col <= 4) {
                        matrix[r][c] = true;
                    }
                    // ä¸­é—´ç•™ç™½
                    else {
                        matrix[r][c] = false;
                    }
                }
            }
        }
    },

    addSeparators: function(matrix, size) {
        // åœ¨å®šä½æ ‡è®°å‘¨å›´æ·»åŠ åˆ†éš”ç¬¦ï¼ˆç™½è‰²è¾¹æ¡†ï¼‰
        const positions = [
            [0, 0], [size - 7, 0], [0, size - 7]
        ];

        positions.forEach(([startRow, startCol]) => {
            for (let row = -1; row <= 7; row++) {
                for (let col = -1; col <= 7; col++) {
                    const r = startRow + row;
                    const c = startCol + col;
                    if (r >= 0 && r < size && c >= 0 && c < size) {
                        if (row === -1 || row === 7 || col === -1 || col === 7) {
                            matrix[r][c] = false;
                        }
                    }
                }
            }
        });
    },

    addTimingPatterns: function(matrix, size) {
        // æ·»åŠ æ—¶åºå›¾æ¡ˆï¼ˆç¬¬6è¡Œå’Œç¬¬6åˆ—çš„äº¤æ›¿æ¨¡å¼ï¼‰
        for (let i = 8; i < size - 8; i++) {
            matrix[6][i] = (i % 2 === 0);
            matrix[i][6] = (i % 2 === 0);
        }
    },

    addDataModules: function(matrix, text, size) {
        // åŸºäºæ–‡æœ¬å†…å®¹ç”Ÿæˆæ•°æ®æ¨¡å—
        const hash = this.simpleHash(text);
        let dataIndex = 0;

        // ä»å³ä¸‹è§’å¼€å§‹ï¼ŒæŒ‰ç…§QRç çš„æ•°æ®å¡«å……æ¨¡å¼
        for (let col = size - 1; col > 0; col -= 2) {
            if (col === 6) col--; // è·³è¿‡æ—¶åºåˆ—

            for (let row = 0; row < size; row++) {
                for (let c = 0; c < 2; c++) {
                    const currentCol = col - c;
                    const currentRow = (col % 4 < 2) ? (size - 1 - row) : row;

                    if (currentRow >= 0 && currentRow < size &&
                        currentCol >= 0 && currentCol < size &&
                        !this.isReservedModule(matrix, currentRow, currentCol, size)) {

                        // åŸºäºhashå’Œä½ç½®ç”Ÿæˆæ•°æ®
                        const bit = ((hash >> (dataIndex % 32)) & 1) === 1;
                        matrix[currentRow][currentCol] = bit;
                        dataIndex++;
                    }
                }
            }
        }
    },

    isReservedModule: function(matrix, row, col, size) {
        // æ£€æŸ¥æ˜¯å¦æ˜¯ä¿ç•™æ¨¡å—ï¼ˆå®šä½æ ‡è®°ã€åˆ†éš”ç¬¦ã€æ—¶åºå›¾æ¡ˆç­‰ï¼‰

        // å®šä½æ ‡è®°åŒºåŸŸ
        if ((row < 9 && col < 9) ||
            (row < 9 && col >= size - 8) ||
            (row >= size - 8 && col < 9)) {
            return true;
        }

        // æ—¶åºå›¾æ¡ˆ
        if (row === 6 || col === 6) {
            return true;
        }

        return false;
    },

    simpleHash: function(str) {
        let hash = 0;
        for (let i = 0; i < str.length; i++) {
            const char = str.charCodeAt(i);
            hash = ((hash << 5) - hash) + char;
            hash = hash & hash;
        }
        return Math.abs(hash);
    },
    
    showFallbackText: function(container, text) {
        // é™çº§æ–¹æ¡ˆï¼šæ˜¾ç¤ºæ‰‹åŠ¨è¾“å…¥ç•Œé¢
        console.log('æ˜¾ç¤ºé™çº§æ–¹æ¡ˆ');

        // æå–å¯†é’¥
        const secretMatch = text.match(/secret=([A-Z2-7]+)/);
        const secret = secretMatch ? secretMatch[1] : 'UNKNOWN';

        container.innerHTML = `
            <div style="border: 2px dashed #e5e7eb; padding: 20px; text-align: center; border-radius: 8px; background: #f9fafb;">
                <div style="margin-bottom: 15px;">
                    <i class="fas fa-mobile-alt" style="font-size: 48px; color: #6b7280;"></i>
                </div>
                <h6 style="margin: 0 0 15px 0; color: #374151;">æ‰‹åŠ¨æ·»åŠ åˆ°Google Authenticator</h6>

                <div style="background: #ffffff; border: 1px solid #d1d5db; padding: 15px; border-radius: 6px; margin: 15px 0; text-align: left;">
                    <div style="margin-bottom: 10px;">
                        <strong>è´¦æˆ·åç§°ï¼š</strong> PGS Tracking System
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>å‘è¡Œè€…ï¼š</strong> PGS Admin
                    </div>
                    <div style="margin-bottom: 10px;">
                        <strong>å¯†é’¥ï¼š</strong>
                        <div style="background: #f3f4f6; padding: 8px; border-radius: 4px; font-family: monospace; word-break: break-all; margin-top: 5px; position: relative;">
                            ${secret}
                            <button onclick="copyToClipboard('${secret}')" style="position: absolute; top: 2px; right: 2px; background: #2563eb; color: white; border: none; padding: 4px 8px; border-radius: 3px; font-size: 11px; cursor: pointer;">
                                å¤åˆ¶
                            </button>
                        </div>
                    </div>
                    <div>
                        <strong>ç±»å‹ï¼š</strong> åŸºäºæ—¶é—´
                    </div>
                </div>

                <div style="font-size: 12px; color: #6b7280; line-height: 1.4;">
                    <p style="margin: 0;">åœ¨Google Authenticatorä¸­ï¼š</p>
                    <p style="margin: 5px 0 0 0;">ç‚¹å‡»"+" â†’ "æ‰‹åŠ¨è¾“å…¥å¯†é’¥" â†’ è¾“å…¥ä¸Šæ–¹ä¿¡æ¯</p>
                </div>
            </div>
        `;
    }
};

// å…¨å±€å¤åˆ¶å‡½æ•°
window.copyToClipboard = function(text) {
    if (navigator.clipboard) {
        navigator.clipboard.writeText(text).then(() => {
            alert('å¯†é’¥å·²å¤åˆ¶åˆ°å‰ªè´´æ¿');
        }).catch(() => {
            prompt('è¯·æ‰‹åŠ¨å¤åˆ¶å¯†é’¥:', text);
        });
    } else {
        prompt('è¯·æ‰‹åŠ¨å¤åˆ¶å¯†é’¥:', text);
    }
};

// å…¨å±€æ‰‹åŠ¨è¾“å…¥åˆ‡æ¢å‡½æ•°
window.showManualInput = function() {
    const qrcodeContainer = document.getElementById('qrcode');
    if (qrcodeContainer && window.currentSecret) {
        const otpAuthUrl = `otpauth://totp/PGS%20Admin:PGS%20Tracking%20System?secret=${window.currentSecret}&issuer=PGS%20Admin&algorithm=SHA1&digits=6&period=30`;
        window.QRCode.showFallbackText(qrcodeContainer, otpAuthUrl);
    }
};
