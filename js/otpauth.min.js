/**
 * OTPAuth - æ ‡å‡†TOTPå®ç°
 * å…¼å®¹Google Authenticatorçš„æ ‡å‡†TOTPç®—æ³•
 */

window.OTPAuth = {
    Secret: {
        fromBase32: function(base32String) {
            return base32String;
        }
    },

    TOTP: class {
        constructor(options) {
            this.issuer = options.issuer || 'PGS';
            this.label = options.label || 'PGS Tracking System';
            this.algorithm = options.algorithm || 'SHA1';
            this.digits = options.digits || 6;
            this.period = options.period || 30;
            this.secret = options.secret;
        }

        toString() {
            // ç”Ÿæˆæ ‡å‡†çš„otpauth URL
            const params = new URLSearchParams({
                secret: this.secret,
                issuer: this.issuer,
                algorithm: this.algorithm,
                digits: this.digits,
                period: this.period
            });

            return `otpauth://totp/${encodeURIComponent(this.issuer)}:${encodeURIComponent(this.label)}?${params.toString()}`;
        }

        async generate(options = {}) {
            // ç›´æ¥ä½¿ç”¨åŒæ­¥ç‰ˆæœ¬ï¼Œç¡®ä¿ä¸Google Authenticatorå…¼å®¹
            return this.generateSync(options);
        }

        generateSync(options = {}) {
            const timestamp = options.timestamp || Date.now();
            const timeStep = Math.floor(timestamp / 1000 / this.period);

            console.log('ğŸ” TOTPç”Ÿæˆè°ƒè¯•:');
            console.log('è¾“å…¥æ—¶é—´æˆ³:', timestamp);
            console.log('æ—¶é—´æ­¥é•¿:', timeStep);
            console.log('å‘¨æœŸ:', this.period);
            console.log('å¯†é’¥:', this.secret);

            try {
                // ä½¿ç”¨ä¿®å¤çš„Base32è§£ç 
                const key = this.fixedBase32Decode(this.secret);
                console.log('ğŸ” è§£ç åçš„å¯†é’¥é•¿åº¦:', key.length);
                console.log('ğŸ” è§£ç åçš„å¯†é’¥(hex):', key.map(b => b.toString(16).padStart(2, '0')).join(''));

                // æ„é€ 8å­—èŠ‚å¤§ç«¯åºæ—¶é—´æ­¥é•¿
                const data = [];
                for (let i = 7; i >= 0; i--) {
                    data.push((timeStep >>> (i * 8)) & 0xff);
                }
                console.log('ğŸ” æ—¶é—´å­—èŠ‚:', data.map(b => b.toString(16).padStart(2, '0')).join(''));

                // ä½¿ç”¨HMAC-SHA1
                const hash = this.hmacSHA1Fallback(key, data);
                console.log('ğŸ” HMACç»“æœ:', hash.map(b => b.toString(16).padStart(2, '0')).join(''));

                // åŠ¨æ€æˆªå–ï¼ˆRFC 4226æ ‡å‡†ï¼‰
                const offset = hash[hash.length - 1] & 0xf;
                console.log('ğŸ” åç§»é‡:', offset);

                const code = ((hash[offset] & 0x7f) << 24) |
                           ((hash[offset + 1] & 0xff) << 16) |
                           ((hash[offset + 2] & 0xff) << 8) |
                           (hash[offset + 3] & 0xff);

                console.log('ğŸ” åŸå§‹ä»£ç :', code);

                const otp = (code % Math.pow(10, this.digits)).toString().padStart(this.digits, '0');
                console.log('ğŸ” ç”Ÿæˆçš„OTP:', otp);
                return otp;
            } catch (error) {
                console.error('TOTP generation error:', error);
                throw error;
            }
        }

        async hmacSHA1(key, data) {
            // ä½¿ç”¨Web Crypto APIå®ç°æ ‡å‡†HMAC-SHA1
            try {
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(key),
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign(
                    'HMAC',
                    cryptoKey,
                    new Uint8Array(data)
                );

                return Array.from(new Uint8Array(signature));
            } catch (error) {
                console.warn('Web Crypto APIä¸å¯ç”¨ï¼Œä½¿ç”¨å¤‡ç”¨å®ç°');
                return this.hmacSHA1Fallback(key, data);
            }
        }

        hmacSHA1Fallback(key, data) {
            // å¤‡ç”¨çš„HMAC-SHA1å®ç°
            const blockSize = 64;
            const outputSize = 20;

            // å¦‚æœå¯†é’¥é•¿åº¦å¤§äºå—å¤§å°ï¼Œå…ˆè¿›è¡ŒSHA1å“ˆå¸Œ
            if (key.length > blockSize) {
                key = this.sha1(key);
            }

            // å¡«å……å¯†é’¥åˆ°å—å¤§å°
            const keyPadded = new Array(blockSize).fill(0);
            for (let i = 0; i < key.length; i++) {
                keyPadded[i] = key[i];
            }

            // è®¡ç®—å†…éƒ¨å’Œå¤–éƒ¨å¡«å……
            const ipad = keyPadded.map(b => b ^ 0x36);
            const opad = keyPadded.map(b => b ^ 0x5c);

            // HMAC = SHA1(opad || SHA1(ipad || message))
            const innerHash = this.sha1(ipad.concat(data));
            return this.sha1(opad.concat(innerHash));
        }

        sha1(data) {
            // ç®€åŒ–çš„SHA1å®ç°ï¼ˆä»…ç”¨äºå¤‡ç”¨ï¼‰
            const h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
            const dataBytes = Array.isArray(data) ? data : Array.from(data);

            // é¢„å¤„ç†
            const msgLen = dataBytes.length;
            const bitLen = msgLen * 8;

            // æ·»åŠ å¡«å……
            dataBytes.push(0x80);
            while ((dataBytes.length % 64) !== 56) {
                dataBytes.push(0);
            }

            // æ·»åŠ é•¿åº¦
            for (let i = 7; i >= 0; i--) {
                dataBytes.push((bitLen >>> (i * 8)) & 0xff);
            }

            // å¤„ç†512ä½å—
            for (let chunk = 0; chunk < dataBytes.length; chunk += 64) {
                const w = new Array(80);

                // å¤åˆ¶å—åˆ°w[0..15]
                for (let i = 0; i < 16; i++) {
                    w[i] = (dataBytes[chunk + i * 4] << 24) |
                           (dataBytes[chunk + i * 4 + 1] << 16) |
                           (dataBytes[chunk + i * 4 + 2] << 8) |
                           dataBytes[chunk + i * 4 + 3];
                }

                // æ‰©å±•åˆ°w[16..79]
                for (let i = 16; i < 80; i++) {
                    w[i] = this.rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
                }

                let [a, b, c, d, e] = h;

                // ä¸»å¾ªç¯
                for (let i = 0; i < 80; i++) {
                    let f, k;
                    if (i < 20) {
                        f = (b & c) | (~b & d);
                        k = 0x5A827999;
                    } else if (i < 40) {
                        f = b ^ c ^ d;
                        k = 0x6ED9EBA1;
                    } else if (i < 60) {
                        f = (b & c) | (b & d) | (c & d);
                        k = 0x8F1BBCDC;
                    } else {
                        f = b ^ c ^ d;
                        k = 0xCA62C1D6;
                    }

                    const temp = (this.rotateLeft(a, 5) + f + e + k + w[i]) & 0xffffffff;
                    e = d;
                    d = c;
                    c = this.rotateLeft(b, 30);
                    b = a;
                    a = temp;
                }

                h[0] = (h[0] + a) & 0xffffffff;
                h[1] = (h[1] + b) & 0xffffffff;
                h[2] = (h[2] + c) & 0xffffffff;
                h[3] = (h[3] + d) & 0xffffffff;
                h[4] = (h[4] + e) & 0xffffffff;
            }

            // è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
            const result = [];
            for (let i = 0; i < 5; i++) {
                result.push((h[i] >>> 24) & 0xff);
                result.push((h[i] >>> 16) & 0xff);
                result.push((h[i] >>> 8) & 0xff);
                result.push(h[i] & 0xff);
            }

            return result;
        }

        rotateLeft(n, s) {
            return ((n << s) | (n >>> (32 - s))) & 0xffffffff;
        }

        base32Decode(encoded) {
            // æ ‡å‡†Base32è§£ç 
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            const cleanInput = encoded.replace(/[^A-Z2-7]/g, '');

            let bits = '';
            for (let i = 0; i < cleanInput.length; i++) {
                const char = cleanInput[i];
                const index = alphabet.indexOf(char);
                if (index === -1) continue;
                bits += index.toString(2).padStart(5, '0');
            }

            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                const byte = bits.substr(i, 8);
                if (byte.length === 8) {
                    bytes.push(parseInt(byte, 2));
                }
            }

            return bytes;
        }

        intToBytes(num) {
            const bytes = [];
            for (let i = 7; i >= 0; i--) {
                bytes.push((num >>> (i * 8)) & 0xff);
            }
            return bytes;
        }

        // ä¿®å¤çš„Base32è§£ç ï¼ˆRFC 4648æ ‡å‡†ï¼‰
        fixedBase32Decode(encoded) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

            // ç§»é™¤å¡«å……å’Œç©ºæ ¼ï¼Œè½¬å¤§å†™
            encoded = encoded.replace(/[=\s]/g, '').toUpperCase();

            let bits = '';
            for (let i = 0; i < encoded.length; i++) {
                const val = alphabet.indexOf(encoded.charAt(i));
                if (val === -1) throw new Error('Invalid base32 character: ' + encoded.charAt(i));
                bits += val.toString(2).padStart(5, '0');
            }

            // è½¬æ¢ä¸ºå­—èŠ‚æ•°ç»„
            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                if (i + 8 <= bits.length) {
                    bytes.push(parseInt(bits.substr(i, 8), 2));
                }
            }

            return bytes;
        }

        // ä½¿ç”¨Web Crypto APIçš„HMAC-SHA1
        async webCryptoHmacSHA1(key, data) {
            try {
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(key),
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign('HMAC', cryptoKey, new Uint8Array(data));
                return Array.from(new Uint8Array(signature));
            } catch (error) {
                console.warn('Web Crypto APIå¤±è´¥ï¼Œä½¿ç”¨fallback:', error);
                return this.hmacSHA1Fallback(key, data);
            }
        }
    }
};
