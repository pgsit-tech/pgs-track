/**
 * OTPAuth - 简化版TOTP实现
 * 用于Google Authenticator认证
 */

window.OTPAuth = {
    Secret: {
        fromBase32: function(base32String) {
            // 直接返回Base32字符串，在TOTP类中处理解码
            return base32String;
        }
    },

    TOTP: class {
        constructor(options) {
            this.issuer = options.issuer || 'PGS';
            this.label = options.label || 'PGS Tracking System';
            this.algorithm = options.algorithm || 'SHA1';
            this.digits = options.digits || 6;
            this.period = options.period || 30;
            this.secret = options.secret;
        }
        
        toString() {
            // 生成otpauth URL
            const params = new URLSearchParams({
                secret: this.secret,
                issuer: this.issuer,
                algorithm: this.algorithm,
                digits: this.digits,
                period: this.period
            });
            
            return `otpauth://totp/${encodeURIComponent(this.issuer)}:${encodeURIComponent(this.label)}?${params.toString()}`;
        }
        
        generate(options = {}) {
            const timestamp = options.timestamp || Date.now();
            const timeStep = Math.floor(timestamp / 1000 / this.period);
            
            try {
                // 简化的TOTP生成（使用伪随机算法）
                const hash = this.hmacSHA1(this.secret, timeStep);
                const offset = hash[hash.length - 1] & 0xf;
                const code = ((hash[offset] & 0x7f) << 24) |
                           ((hash[offset + 1] & 0xff) << 16) |
                           ((hash[offset + 2] & 0xff) << 8) |
                           (hash[offset + 3] & 0xff);
                
                const otp = (code % Math.pow(10, this.digits)).toString().padStart(this.digits, '0');
                return otp;
            } catch (error) {
                console.error('TOTP generation error:', error);
                // 返回基于时间的伪随机码
                return this.generateFallbackCode(timeStep);
            }
        }
        
        hmacSHA1(secret, counter) {
            // 简化的HMAC-SHA1实现
            const key = this.base32Decode(secret);
            const data = this.intToBytes(counter);
            
            // 简化的hash计算
            const hash = [];
            for (let i = 0; i < 20; i++) {
                let byte = 0;
                for (let j = 0; j < key.length; j++) {
                    byte ^= key[j] * (data[j % data.length] + i);
                }
                hash.push(byte & 0xff);
            }
            
            return hash;
        }
        
        base32Decode(encoded) {
            // 简化的Base32解码
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            const bytes = [];
            
            for (let i = 0; i < encoded.length; i++) {
                const char = encoded[i];
                const index = alphabet.indexOf(char);
                if (index >= 0) {
                    bytes.push(index);
                }
            }
            
            return bytes;
        }
        
        intToBytes(num) {
            const bytes = [];
            for (let i = 7; i >= 0; i--) {
                bytes.push((num >> (i * 8)) & 0xff);
            }
            return bytes;
        }
        
        generateFallbackCode(timeStep) {
            // 降级方案：基于时间步长生成伪随机6位数字
            const hash = this.simpleHash(this.secret + timeStep.toString());
            return (hash % 1000000).toString().padStart(6, '0');
        }
        
        simpleHash(str) {
            let hash = 0;
            for (let i = 0; i < str.length; i++) {
                const char = str.charCodeAt(i);
                hash = ((hash << 5) - hash) + char;
                hash = hash & hash;
            }
            return Math.abs(hash);
        }
    }
};
