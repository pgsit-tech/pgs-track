/**
 * OTPAuth - 标准TOTP实现
 * 兼容Google Authenticator的标准TOTP算法
 */

window.OTPAuth = {
    Secret: {
        fromBase32: function(base32String) {
            return base32String;
        }
    },

    TOTP: class {
        constructor(options) {
            this.issuer = options.issuer || 'PGS';
            this.label = options.label || 'PGS Tracking System';
            this.algorithm = options.algorithm || 'SHA1';
            this.digits = options.digits || 6;
            this.period = options.period || 30;
            this.secret = options.secret;
        }

        toString() {
            // 生成标准的otpauth URL
            const params = new URLSearchParams({
                secret: this.secret,
                issuer: this.issuer,
                algorithm: this.algorithm,
                digits: this.digits,
                period: this.period
            });

            return `otpauth://totp/${encodeURIComponent(this.issuer)}:${encodeURIComponent(this.label)}?${params.toString()}`;
        }

        async generate(options = {}) {
            // 直接使用同步版本，确保与Google Authenticator兼容
            return this.generateSync(options);
        }

        generateSync(options = {}) {
            const timestamp = options.timestamp || Date.now();
            const timeStep = Math.floor(timestamp / 1000 / this.period);

            console.log('🔍 TOTP生成调试:');
            console.log('输入时间戳:', timestamp);
            console.log('时间步长:', timeStep);
            console.log('周期:', this.period);
            console.log('密钥:', this.secret);

            try {
                // 使用修复的Base32解码
                const key = this.fixedBase32Decode(this.secret);
                console.log('🔍 解码后的密钥长度:', key.length);
                console.log('🔍 解码后的密钥(hex):', key.map(b => b.toString(16).padStart(2, '0')).join(''));

                // 构造8字节大端序时间步长
                const data = [];
                for (let i = 7; i >= 0; i--) {
                    data.push((timeStep >>> (i * 8)) & 0xff);
                }
                console.log('🔍 时间字节:', data.map(b => b.toString(16).padStart(2, '0')).join(''));

                // 使用HMAC-SHA1
                const hash = this.hmacSHA1Fallback(key, data);
                console.log('🔍 HMAC结果:', hash.map(b => b.toString(16).padStart(2, '0')).join(''));

                // 动态截取（RFC 4226标准）
                const offset = hash[hash.length - 1] & 0xf;
                console.log('🔍 偏移量:', offset);

                const code = ((hash[offset] & 0x7f) << 24) |
                           ((hash[offset + 1] & 0xff) << 16) |
                           ((hash[offset + 2] & 0xff) << 8) |
                           (hash[offset + 3] & 0xff);

                console.log('🔍 原始代码:', code);

                const otp = (code % Math.pow(10, this.digits)).toString().padStart(this.digits, '0');
                console.log('🔍 生成的OTP:', otp);
                return otp;
            } catch (error) {
                console.error('TOTP generation error:', error);
                throw error;
            }
        }

        async hmacSHA1(key, data) {
            // 使用Web Crypto API实现标准HMAC-SHA1
            try {
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(key),
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign(
                    'HMAC',
                    cryptoKey,
                    new Uint8Array(data)
                );

                return Array.from(new Uint8Array(signature));
            } catch (error) {
                console.warn('Web Crypto API不可用，使用备用实现');
                return this.hmacSHA1Fallback(key, data);
            }
        }

        hmacSHA1Fallback(key, data) {
            // 备用的HMAC-SHA1实现
            const blockSize = 64;
            const outputSize = 20;

            // 如果密钥长度大于块大小，先进行SHA1哈希
            if (key.length > blockSize) {
                key = this.sha1(key);
            }

            // 填充密钥到块大小
            const keyPadded = new Array(blockSize).fill(0);
            for (let i = 0; i < key.length; i++) {
                keyPadded[i] = key[i];
            }

            // 计算内部和外部填充
            const ipad = keyPadded.map(b => b ^ 0x36);
            const opad = keyPadded.map(b => b ^ 0x5c);

            // HMAC = SHA1(opad || SHA1(ipad || message))
            const innerHash = this.sha1(ipad.concat(data));
            return this.sha1(opad.concat(innerHash));
        }

        sha1(data) {
            // 简化的SHA1实现（仅用于备用）
            const h = [0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0];
            const dataBytes = Array.isArray(data) ? data : Array.from(data);

            // 预处理
            const msgLen = dataBytes.length;
            const bitLen = msgLen * 8;

            // 添加填充
            dataBytes.push(0x80);
            while ((dataBytes.length % 64) !== 56) {
                dataBytes.push(0);
            }

            // 添加长度
            for (let i = 7; i >= 0; i--) {
                dataBytes.push((bitLen >>> (i * 8)) & 0xff);
            }

            // 处理512位块
            for (let chunk = 0; chunk < dataBytes.length; chunk += 64) {
                const w = new Array(80);

                // 复制块到w[0..15]
                for (let i = 0; i < 16; i++) {
                    w[i] = (dataBytes[chunk + i * 4] << 24) |
                           (dataBytes[chunk + i * 4 + 1] << 16) |
                           (dataBytes[chunk + i * 4 + 2] << 8) |
                           dataBytes[chunk + i * 4 + 3];
                }

                // 扩展到w[16..79]
                for (let i = 16; i < 80; i++) {
                    w[i] = this.rotateLeft(w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16], 1);
                }

                let [a, b, c, d, e] = h;

                // 主循环
                for (let i = 0; i < 80; i++) {
                    let f, k;
                    if (i < 20) {
                        f = (b & c) | (~b & d);
                        k = 0x5A827999;
                    } else if (i < 40) {
                        f = b ^ c ^ d;
                        k = 0x6ED9EBA1;
                    } else if (i < 60) {
                        f = (b & c) | (b & d) | (c & d);
                        k = 0x8F1BBCDC;
                    } else {
                        f = b ^ c ^ d;
                        k = 0xCA62C1D6;
                    }

                    const temp = (this.rotateLeft(a, 5) + f + e + k + w[i]) & 0xffffffff;
                    e = d;
                    d = c;
                    c = this.rotateLeft(b, 30);
                    b = a;
                    a = temp;
                }

                h[0] = (h[0] + a) & 0xffffffff;
                h[1] = (h[1] + b) & 0xffffffff;
                h[2] = (h[2] + c) & 0xffffffff;
                h[3] = (h[3] + d) & 0xffffffff;
                h[4] = (h[4] + e) & 0xffffffff;
            }

            // 转换为字节数组
            const result = [];
            for (let i = 0; i < 5; i++) {
                result.push((h[i] >>> 24) & 0xff);
                result.push((h[i] >>> 16) & 0xff);
                result.push((h[i] >>> 8) & 0xff);
                result.push(h[i] & 0xff);
            }

            return result;
        }

        rotateLeft(n, s) {
            return ((n << s) | (n >>> (32 - s))) & 0xffffffff;
        }

        base32Decode(encoded) {
            // 标准Base32解码
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            const cleanInput = encoded.replace(/[^A-Z2-7]/g, '');

            let bits = '';
            for (let i = 0; i < cleanInput.length; i++) {
                const char = cleanInput[i];
                const index = alphabet.indexOf(char);
                if (index === -1) continue;
                bits += index.toString(2).padStart(5, '0');
            }

            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                const byte = bits.substr(i, 8);
                if (byte.length === 8) {
                    bytes.push(parseInt(byte, 2));
                }
            }

            return bytes;
        }

        intToBytes(num) {
            const bytes = [];
            for (let i = 7; i >= 0; i--) {
                bytes.push((num >>> (i * 8)) & 0xff);
            }
            return bytes;
        }

        // 修复的Base32解码（RFC 4648标准）
        fixedBase32Decode(encoded) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';

            // 移除填充和空格，转大写
            encoded = encoded.replace(/[=\s]/g, '').toUpperCase();

            let bits = '';
            for (let i = 0; i < encoded.length; i++) {
                const val = alphabet.indexOf(encoded.charAt(i));
                if (val === -1) throw new Error('Invalid base32 character: ' + encoded.charAt(i));
                bits += val.toString(2).padStart(5, '0');
            }

            // 转换为字节数组
            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                if (i + 8 <= bits.length) {
                    bytes.push(parseInt(bits.substr(i, 8), 2));
                }
            }

            return bytes;
        }

        // 使用Web Crypto API的HMAC-SHA1
        async webCryptoHmacSHA1(key, data) {
            try {
                const cryptoKey = await crypto.subtle.importKey(
                    'raw',
                    new Uint8Array(key),
                    { name: 'HMAC', hash: 'SHA-1' },
                    false,
                    ['sign']
                );

                const signature = await crypto.subtle.sign('HMAC', cryptoKey, new Uint8Array(data));
                return Array.from(new Uint8Array(signature));
            } catch (error) {
                console.warn('Web Crypto API失败，使用fallback:', error);
                return this.hmacSHA1Fallback(key, data);
            }
        }
    }
};
