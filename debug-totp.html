<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TOTPè°ƒè¯•å¯¹æ¯”</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .container { max-width: 1000px; margin: 0 auto; }
        .result { background: #f5f5f5; padding: 15px; margin: 10px 0; border-radius: 5px; }
        .error { background: #ffebee; color: #c62828; }
        .success { background: #e8f5e8; color: #2e7d32; }
        .warning { background: #fff3e0; color: #f57c00; }
        pre { white-space: pre-wrap; word-wrap: break-word; font-size: 12px; }
        button { padding: 10px 20px; margin: 5px; cursor: pointer; }
        input { padding: 8px; margin: 5px; width: 300px; }
        .compare { display: flex; gap: 20px; }
        .compare > div { flex: 1; }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ” TOTPç®—æ³•è°ƒè¯•å¯¹æ¯”</h1>
        
        <div>
            <label>æµ‹è¯•å¯†é’¥:</label>
            <input type="text" id="testSecret" value="JBSWY3DPEHPK3PXP" placeholder="è¾“å…¥Base32å¯†é’¥">
            <button onclick="useRFCTestKey()">ä½¿ç”¨RFCæµ‹è¯•å¯†é’¥</button>
        </div>
        
        <div>
            <button onclick="compareAlgorithms()">å¯¹æ¯”ç®—æ³•å®ç°</button>
            <button onclick="testCurrentTime()">æµ‹è¯•å½“å‰æ—¶é—´</button>
            <button onclick="testFixedTime()">æµ‹è¯•å›ºå®šæ—¶é—´</button>
            <button onclick="clearResults()">æ¸…é™¤ç»“æœ</button>
        </div>
        
        <div id="results"></div>
    </div>

    <script>
        function addResult(title, content, type = 'result') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.innerHTML = `<h3>${title}</h3><pre>${content}</pre>`;
            results.appendChild(div);
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
        }

        function useRFCTestKey() {
            document.getElementById('testSecret').value = 'JBSWY3DPEHPK3PXP';
        }

        // æ ‡å‡†Base32è§£ç å®ç°
        function standardBase32Decode(encoded) {
            const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ234567';
            let bits = '';
            
            // ç§»é™¤å¡«å……å’Œç©ºæ ¼ï¼Œè½¬å¤§å†™
            encoded = encoded.replace(/[=\\s]/g, '').toUpperCase();
            
            for (let i = 0; i < encoded.length; i++) {
                const val = alphabet.indexOf(encoded.charAt(i));
                if (val === -1) throw new Error('Invalid base32 character: ' + encoded.charAt(i));
                bits += val.toString(2).padStart(5, '0');
            }
            
            const bytes = [];
            for (let i = 0; i < bits.length; i += 8) {
                if (i + 8 <= bits.length) {
                    bytes.push(parseInt(bits.substr(i, 8), 2));
                }
            }
            return new Uint8Array(bytes);
        }

        // æ ‡å‡†HMAC-SHA1å®ç°ï¼ˆä½¿ç”¨Web Crypto APIï¼‰
        async function standardHmacSHA1(key, data) {
            const cryptoKey = await crypto.subtle.importKey(
                'raw',
                key,
                { name: 'HMAC', hash: 'SHA-1' },
                false,
                ['sign']
            );
            
            const signature = await crypto.subtle.sign('HMAC', cryptoKey, data);
            return new Uint8Array(signature);
        }

        // æ ‡å‡†TOTPå®ç°
        async function standardTOTP(secret, timestamp, period = 30, digits = 6) {
            const key = standardBase32Decode(secret);
            const timeStep = Math.floor(timestamp / 1000 / period);
            
            // æ„é€ 8å­—èŠ‚å¤§ç«¯åºæ—¶é—´æ­¥é•¿
            const data = new ArrayBuffer(8);
            const view = new DataView(data);
            view.setUint32(4, timeStep, false); // å¤§ç«¯åºï¼Œé«˜ä½ä¸º0
            
            const hash = await standardHmacSHA1(key, new Uint8Array(data));
            
            // åŠ¨æ€æˆªå–
            const offset = hash[hash.length - 1] & 0xf;
            const code = ((hash[offset] & 0x7f) << 24) |
                        ((hash[offset + 1] & 0xff) << 16) |
                        ((hash[offset + 2] & 0xff) << 8) |
                        (hash[offset + 3] & 0xff);
            
            return {
                code: (code % Math.pow(10, digits)).toString().padStart(digits, '0'),
                timeStep,
                key: Array.from(key).map(b => b.toString(16).padStart(2, '0')).join(''),
                timeBytes: Array.from(new Uint8Array(data)).map(b => b.toString(16).padStart(2, '0')).join(''),
                hash: Array.from(hash).map(b => b.toString(16).padStart(2, '0')).join(''),
                offset,
                rawCode: code
            };
        }

        async function compareAlgorithms() {
            const secret = document.getElementById('testSecret').value;
            if (!secret) {
                addResult('âŒ é”™è¯¯', 'è¯·è¾“å…¥æµ‹è¯•å¯†é’¥', 'error');
                return;
            }

            try {
                const timestamp = Date.now();
                
                // ä½¿ç”¨æ ‡å‡†ç®—æ³•
                const standard = await standardTOTP(secret, timestamp);
                
                let result = `å¯†é’¥: ${secret}\\n`;
                result += `æ—¶é—´æˆ³: ${timestamp} (${new Date(timestamp).toISOString()})\\n`;
                result += `æ—¶é—´æ­¥é•¿: ${standard.timeStep}\\n\\n`;
                
                result += `=== æ ‡å‡†ç®—æ³•ç»“æœ ===\\n`;
                result += `å¯†é’¥(hex): ${standard.key}\\n`;
                result += `æ—¶é—´å­—èŠ‚(hex): ${standard.timeBytes}\\n`;
                result += `HMACç»“æœ(hex): ${standard.hash}\\n`;
                result += `åç§»é‡: ${standard.offset}\\n`;
                result += `åŸå§‹ä»£ç : ${standard.rawCode}\\n`;
                result += `æœ€ç»ˆéªŒè¯ç : ${standard.code}\\n`;
                
                addResult('ğŸ” ç®—æ³•å¯¹æ¯”ç»“æœ', result, 'success');
                
            } catch (error) {
                addResult('âŒ å¯¹æ¯”å¤±è´¥', error.message, 'error');
            }
        }

        async function testCurrentTime() {
            const secret = document.getElementById('testSecret').value;
            if (!secret) {
                addResult('âŒ é”™è¯¯', 'è¯·è¾“å…¥æµ‹è¯•å¯†é’¥', 'error');
                return;
            }

            try {
                const now = Date.now();
                let result = `å½“å‰æ—¶é—´æµ‹è¯•\\n`;
                result += `æ—¶é—´: ${new Date(now).toISOString()}\\n`;
                result += `æ—¶é—´æˆ³: ${now}\\n\\n`;

                // æµ‹è¯•å½“å‰æ—¶é—´å’Œå‰åå‡ ä¸ªæ—¶é—´çª—å£
                for (let i = -2; i <= 2; i++) {
                    const testTime = now + (i * 30 * 1000);
                    const totp = await standardTOTP(secret, testTime);
                    result += `çª—å£ ${i}: ${totp.code} (${new Date(testTime).toISOString()})\\n`;
                }
                
                addResult('ğŸ• å½“å‰æ—¶é—´çª—å£æµ‹è¯•', result, 'success');
                
            } catch (error) {
                addResult('âŒ æµ‹è¯•å¤±è´¥', error.message, 'error');
            }
        }

        async function testFixedTime() {
            const secret = document.getElementById('testSecret').value;
            if (!secret) {
                addResult('âŒ é”™è¯¯', 'è¯·è¾“å…¥æµ‹è¯•å¯†é’¥', 'error');
                return;
            }

            try {
                // RFC 6238æµ‹è¯•å‘é‡
                const testVectors = [
                    { time: 59, expected: '287082' },
                    { time: 1111111109, expected: '081804' },
                    { time: 1111111111, expected: '050471' },
                    { time: 1234567890, expected: '005924' },
                    { time: 2000000000, expected: '279037' },
                    { time: 20000000000, expected: '353130' }
                ];

                let result = `RFC 6238æµ‹è¯•å‘é‡éªŒè¯\\n`;
                result += `å¯†é’¥: ${secret}\\n\\n`;

                for (const vector of testVectors) {
                    const timestamp = vector.time * 1000;
                    const totp = await standardTOTP(secret, timestamp);
                    const match = totp.code === vector.expected ? 'âœ…' : 'âŒ';
                    result += `æ—¶é—´: ${vector.time} -> æœŸæœ›: ${vector.expected}, å®é™…: ${totp.code} ${match}\\n`;
                }
                
                addResult('ğŸ“‹ RFCæµ‹è¯•å‘é‡éªŒè¯', result, 'result');
                
            } catch (error) {
                addResult('âŒ æµ‹è¯•å¤±è´¥', error.message, 'error');
            }
        }

        // é¡µé¢åŠ è½½æ—¶æ˜¾ç¤ºè¯´æ˜
        window.addEventListener('load', function() {
            addResult('ğŸ“ ä½¿ç”¨è¯´æ˜', `
è¿™ä¸ªé¡µé¢ç”¨äºè°ƒè¯•TOTPç®—æ³•å®ç°ã€‚

1. ä½¿ç”¨æ ‡å‡†çš„Web Crypto APIå®ç°HMAC-SHA1
2. ä½¿ç”¨æ ‡å‡†çš„Base32è§£ç 
3. ä¸¥æ ¼æŒ‰ç…§RFC 6238è§„èŒƒå®ç°

é»˜è®¤ä½¿ç”¨RFC 6238çš„æµ‹è¯•å¯†é’¥ JBSWY3DPEHPK3PXPã€‚
ç‚¹å‡»"æµ‹è¯•å›ºå®šæ—¶é—´"éªŒè¯ç®—æ³•æ­£ç¡®æ€§ã€‚
ç‚¹å‡»"æµ‹è¯•å½“å‰æ—¶é—´"è·å–å½“å‰æ—¶é—´çš„éªŒè¯ç ã€‚
            `, 'result');
        });
    </script>
</body>
</html>
